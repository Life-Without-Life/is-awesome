# -*- coding: utf-8 -*-
"""19PD18 - DPS PS1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LPewug1_ZoD93YSLo9hmzwierKzJg7kq
"""

import string
from sympy import mod_inverse
import math

def additive_cipher(text, mode, key):
    pop = string.ascii_letters
    additiveKey = {}
    cipher_message = ""
    for i in range(26):
        j = (i + key) % 26
        additiveKey[pop[i]] = pop[j]
        additiveKey[pop[i + 26]] = pop[j + 26]
    additiveKey[' '] = ' '
    if mode == 'encrypt':
        for char in text:
            cipher_message += additiveKey[char]
    elif mode == 'decrypt':
        for x in text:
            y = list(additiveKey.keys())[list(additiveKey.values()).index(x)]
            cipher_message += y
    return cipher_message

strz = "hElLo tHeRe"
print(strz)
zrts = additive_cipher(strz, "encrypt", 20)
print(zrts)
strz1 = additive_cipher(zrts, "decrypt", 20)
print(strz1)

def multiplicative_cypher(text,mode,key):
    char_dict={}
    cipher_message = ''
    for i in range(26):
         char_dict[chr(ord('a') + i)]=i
    key_list=list(char_dict.keys())
    inv_char_dict = dict(zip(char_dict.values(),char_dict.keys()))

    if mode == 'encrypt':
        if math.gcd( 26,key) == 1:
            for char in text:
                if char in key_list:
                    new_index=(char_dict[char]*key)%26
                    cipher_message=cipher_message+inv_char_dict[new_index]
                else:
                    cipher_message=cipher_message+char
        else:
            print('invalid key selected')

        return cipher_message

    if mode == 'decrypt':
        mult_inv=mod_inverse(key, 26)
        for char in text:
            if char in key_list:
                new_index=(char_dict[char]*mult_inv)%26
                cipher_message=cipher_message+inv_char_dict[new_index]
            else:
                cipher_message=cipher_message+char

    return cipher_message

strz = "hElLo tHeRe"
print(strz)
zrts = multiplicative_cypher(strz, "encrypt", 19)
print(zrts)
strz1 = multiplicative_cypher(zrts, "decrypt", 19)
print(strz1)

def affine_cipher(text, mode, key):
    pop = string.ascii_letters
    n = len(pop)
    cipher_message = ''
    if mode == 'encrypt':
        for x in text:
            if x in pop:
                i = pop.index(x)
                j = (key[0] * i + key[1]) % n
                cipher_message += pop[j]
            else:
                cipher_message += x
    elif mode == 'decrypt':
        mult_inv=mod_inverse(key[0], n)
        for char in text:
            if char in pop:
                i = pop.index(char)
                j = mult_inv * (i - key[1]) % n
                cipher_message=cipher_message + pop[j]
            else:
                cipher_message=cipher_message+char
    return cipher_message

op1 = affine_cipher(strz, "encrypt", [17, 20])
op2 = affine_cipher(op1, "decrypt", [17, 20])
print(strz)
print(op1)
print(op2)

c_text = "NCJAEZRCLASJLYODEPRLYZRCLASJLCPEHZDTOPDZQLNZTY"
for x in range(5):
    p_txt = additive_cipher(c_text, "decrypt", 13 + x)
    print(13 + x, p_txt, sep='\t')
    p_txt = additive_cipher(c_text, "decrypt", 13 - x)
    print(13 - x, p_txt, sep='\t')
p_txt = additive_cipher(c_text, "decrypt", 11)
print(p_txt)

def vigenere_cipher(string, mode, key):
    key = list(key)
    if len(string) == len(key):
        return  (key)
    else:
        for i in range(len(string) -len(key)):
            key.append(key[i % len(key)])
    key = "".join(key)
    if mode == "encrypt":
        cipher_text = []
        for i in range(len(string)):
            x = (ord(string[i]) +
                 ord(key[i])) % 26
            x += ord('A')
            cipher_text.append(chr(x))
        return  "".join(cipher_text)
    elif mode == 'decrypt':
        orig_text = []
        for i in range(len(string)):
            x = (ord(string[i]) -
                 ord(key[i]) + 26) % 26
            x += ord('A')
            orig_text.append(chr(x))
        return  "".join(orig_text)

strz = "HELLOTHERE"
op1 = vigenere_cipher(strz, "encrypt", "JMP")
op2 = vigenere_cipher(op1, "decrypt", "JMP")
print(strz)
print(op1)
print(op2)

ciphertxt = '''MPYIGOBSRMIDBSYRDIKATXAILFDFKXTPPSNTTNIGTHDELTTXAIREIHSVOBSMLUCFIOEPZIWACRFXICUVXVTOPXDLWPENDHPTSIDDBXWWTZPHNSOCLOUMSNRCCVUUXZHHNWSVXAUHIKLXTIMOICHTYPBHMHXGXHOLWPEWWWWDALOCTSQZELT'''

def sing_freq_attack(str, m):
    freq = {i: str.count(i) for i in set(str)}
    top5 = list(dict(sorted(freq.items(), key=lambda x:x[1]), reverse=True).keys())[:m]
    vals = [ord(str[i]) - ord(top5[i]) for i in range(m)]
    strs = [""] * m
    for i in range(len(strs)):
        for a in str:
            strs[i] += chr((ord(a) - ord('A') + vals[i]) % 26 + ord('A'))
        print(strs[i])

sing_freq_attack(ciphertxt, 5)
sing_freq_attack("B TJNQMF NFTTBHF", 5)

def printString(S, M):
    N = len(S)
    plaintext = [None] * 5
    freq = [0] * 26
    freqSorted = [None] * 26
    used = [0] * 26
    for i in range(N):
        if S[i] != ' ':
            freq[ord(S[i]) - 65] += 1
    for i in range(26):
        freqSorted[i] = freq[i]
    T = "ETAOINSHRDLCUMWFGYPBVKJXQZ"
    freqSorted.sort(reverse = True)
    for i in range(M):
        ch = -1
        for j in range(26):
            if freqSorted[i] == freq[j] and used[j] == 0:
                used[j] = 1
                ch = j
                break
        if ch == -1:
            break
        x = ord(T[i]) - 65 - ch
        curr = ""
        for k in range(N):
            if S[k] == ' ':
                curr += " "
                continue
            y = ord(S[k]) - 65
            y += x
            if y < 0:
                y += 26
            if y > 25:
                y -= 26
            curr += chr(y + 65)
        plaintext[i] = curr
    for i in range(M):
        print(plaintext[i])

printString(ciphertxt, 5)
printString("B TJNQMF NFTTBHF", 5)

def transposition_cipher(txt, mode, key):
    K = len(key)
    P = len(txt)
    row = int(math.ceil(P / K))
    matrix = [ ['X'] * K for i in range(row)]
    t = 0
    if mode == 'encrypt':
        for r in range(row):
            for c,ch in enumerate(txt[t:t+K]):
                matrix[r][c] = ch
            t += K
        sort_order = sorted([(ch, i) for i,ch in enumerate(key)])
        cipher_txt = ''
        for ch,c in sort_order:
            for r in range(row):
                cipher_txt += matrix[r][c]
        return cipher_txt
    elif mode == 'decrypt':
        cipher_txt = txt
        key_order = [key.index(ch) for ch in sorted(list(key))]
        for c in key_order:
            for r,ch in enumerate(cipher_txt[t:t+row]):
                matrix[r][c] = ch
            t += row
        p_txt = ''
        for r in range(row):
            for c in range(K):
                p_txt += matrix[r][c] if matrix[r][c] != 'X' else ''
        return p_txt
    else:
        return "ERROR"

p_txt = 'enemyattackstonight '
key = 'head'
print(p_txt)
c_txt = transposition_cipher(p_txt, "encrypt", key)
print(c_txt)
print(transposition_cipher(c_txt, "decrypt", key))

p_txt = 'enemyattackstonight '
key = 'head'
key1 = 'fade'
print(p_txt)
c1_txt = transposition_cipher(p_txt, "encrypt", key)
c2_txt = transposition_cipher(c1_txt, "encrypt", key1)
p1_txt = transposition_cipher(c2_txt, "decrypt", key1)
p2_txt = transposition_cipher(p1_txt, "decrypt", key)
print(c1_txt)
print(c2_txt)
print(p1_txt)
print(p2_txt)

len(p_txt)